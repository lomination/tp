#!/usr/bin/env bash


# This script is from https://github.com/lomination/tp.
# This code is under license GNU General Public License version 3.


### Ansi escape codes ###

none='\033[0m'
bold='\033[1m'
decrease='\033[2m'
italics='\033[3m'
underline='\033[4m'
reverse='\033[7m'
red='\033[31m'
green='\033[32m'
yellow='\033[33m'
blue='\033[34m'
magenta='\033[35m'
white='\033[37m'
framed='\033[51m'
bright_yellow='\033[93m'
bright_blue='\033[94m'


### Styles ###

code="$italics$green"
information="$underline"
title="$bold$reverse"
note="${bright_blue}NOTE: "
warn="${bright_yellow}WARNING: "


### Outputs management ###

# The path of the logfile
logfile="$(mktemp '/tmp/tp-log-XXXXXXXXXXXXXXXXXXXX.log')"
exec 3>&1          # redirect 3 -> 1
exec &> "$logfile" # redirect 1 -> $logfile


### Config management ###

# The path to the conf
conf_path="$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )/tp.conf"

# Is 'true' or 'false' depending on whether the configuration file exists
conf_is_valid=''
if [[ -f "$conf_path" ]] && [[ -r "$conf_path" ]]; then
	conf_is_valid='true'
else
	conf_is_valid='false'
fi

# Returns 'true' or 'false' depending on the value of the given key in the configuration.
# If the key is not found, returns the given default value. If the configuration file
# contains '<key>=true' and '<key>=false', returns true.
#
# Takes as parameter the searched key and the default value 'true' or 'false'.
conf_contains() {

	# The key to search in the configuration
	pattern="$1"
	# The default value of the searched key
	default="$2"
	if [[ "$conf_is_valid" == 'false' ]]; then
		return "$default"
	elif [[ "$(cat "$conf_path")" == *"${pattern}=true"* ]]; then
		return 'true'
	elif [[ "$(cat "$conf_path")" == *"${pattern}=false"* ]]; then
		return 'false'
	else
		return "$default"
	fi

}

# Whether short explanations are displayed while running
conf_log_on_std="$(conf_contains 'log_in_std' 'true')"

# Whether added changes are displayed when git add is performed
conf_list_added_changes="$(conf_contains 'list_added_changes' 'false')"


### Utility functions ###

# Prints the given string in the standard output.
myecho() {

	msg="$1"
	echo -e "$msg" >&3 # TODO

}

# Logs the given message. Writes it in the logfile and the standard output if conf_log_on_std is set to 'true'.
log() {

	msg="$1"
	# echoing to logfile
	echo -e ">>> $msg"
	# echoing to stdout
	if [[ "$conf_log_on_std" == 'true' ]]; then
		myecho "$decrease$msg...$none"
	fi

}

# Removes the current logfile given as parameter.
del_logfile() {

	rm "$logfile"

}

# Shows a failure message and exit the execution with exit code 1.
die() {

	msg="$1"
	if [[ -z "$msg" ]]; then
		myecho "$blod${red}Fatal error!$none (logfile: $logfile)"
	else
		echo -e "Fatal error: $msg"
		myecho "$blod${red}Fatal error:$none $msg (logfile: $logfile)"
	fi
	exit 1

}

# Shows a success message and exit the execution with exit code 0. Also removes the current logfile.
success() {

	msg="$1"
	del_logfile
	if [[ -z "$msg" ]]; then
		myecho "$bold${green}Success!$none"
	else
		myecho "$bold${green}Success:$none $msg"
	fi
	exit 0

}


### Aliases ###

# Shows git log.
log_alias() {

	del_logfile
	git log --color --graph --pretty=format:'%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit -- >& 3
	exit 0

}


# Show git status.
status_alias() {

	del_logfile
	git status -sb >& 3
	exit 0

}

# Pulls the remote repository
pull_alias() {

	del_logfile
	git pull
	success 'repository successfully pulled!'

}


### Commands ###

# Creates the practical environment.
init_cmd() {

	# Display help
	if [[ "$1" == '--help' || "$1" == '-h' || "$1" == '-?' ]]; then
		del_logfile
		msg=$(
			cat <<-END
				${title}(DESCRIPTION)$none

				\tThe ${code}tp init$none command makes the beginning of your practical ${information}quicker$none and ${information}easier$none. It should be used ${information}only once$none at the beginning of your practical. This command clones your repo, creates the main and the test C# solutions, then adds default .gitignore and README files and finally commits and pushes the work.

				${title}(USAGE)$none

				\tIt takes as parameter the title of the ${information}current practical's title$none and the ${information}git url${none} of the empty repo to clone. Both can be found on the intra forge's web site.

				\tUsage: ${code}tp init <title> <git_url>${none}

				${title}(EXAMPLES)$none

				\t${code}tp init \"GaulishMall\" \"firsname.lastname@git.forge.epita.fr:p/epita-prepa-computer-science/prog-...-2029/epita-prepa-computer-science-prog-...-2029-firstname.lastname.git\"$none
			END
		)
		myecho "$msg"
		exit 0
	fi

	# The title of the practical
	title="$1"

	# The url to the git repository of the practical.
	git_url="$2"

	# Check if the given arguments are valid
	log "Checking arguments"
	if [[ -z "$title" ]]; then
		die "Missing required argument 'title' at position 1. Check out ${code}tp help init$none."
	fi
	if [[ -z "$git_url" ]]; then
		die "Missing required argument 'git_url' at position 2. Check out ${code}tp help init$none."
	fi

	# Clone the git repository
	log "Cloning the repository"
	git clone "$git_url" "$title" || die

	# Go to the cloned repository
	cd "$title"

	# Create dotnet solution
	log "Creating the dotnet solution"
	dotnet new sln --name "$title" || die

	# Create main project
	log "Creating the dotnet console project"
	dotnet new console -n "$title" -f net7.0 -lang 'C#' || die
	dotnet sln add "$title/$title.csproj" || die

	# Create test project
	log "Creating the dotnet xunit project"
	dotnet new xunit -n "Tests" -f net7.0 -lang 'C#' || die
	dotnet sln add "Tests/Tests.csproj" || die
	dotnet add Tests/Tests.csproj reference "$title/$title.csproj" || die
	echo -e "\nglobal using $title;" >> 'Tests/GlobalUsings.cs' || die

	# Create the .gitignore and README files
	log "Creating the .gitignore and README files"
	echo -e 'bin/\nobj/\n\n.idea/\n*~\n*.DotSettings.user\n.vscode' > .gitignore || die
	echo "$title" > README || die

	# Push the changes on the remote
	log "Synchronizing the git remote"
	git add -A || die
	git commit -m "First commit"  || die
	git push || die

	success
}


# Pushes the work on the intra.
save_cmd() {

	# Display help
	if [[ "$1" == '--help' || "$1" == '-h' || "$1" == '-?' ]]; then
		del_logfile
		msg=$(
			cat <<-END
				${title}(DESCRIPTION)$none

				\tThis command is a shortcut for ${information}git add$none, ${information}git commit$none and ${information}git push$none.

				\t${warn}It adds every current changes in the repository. Make sure to have an appropriate .gitignore file to avoid pushing trash file on the remote!$none

				${title}(USAGE)$none

				\tIt takes as parameter the ${information}name of the commit$none that will be created and pushed. If none is given, a ${information}random one is generated$none.

				\tUsages:
				\t- ${code}tp save <commit_name>${none}
				\t- ${code}tp save${none}

				${title}(EXAMPLES)$none
				\t
				\t${code}tp save \"Fix NegaFibonacci encoding algorithm\"$none
				\t${code}tp save$none
			END
		)
		myecho "$msg"
		exit 0
	fi

	# Testing if there are changes to commit
	if [[ $(git status --porcelain | wc -l) == '0' ]]; then
		success "Nothing to commit, the git working tree is clean."
	fi

	# Choosing a commit name
	if [[ -n "$1" ]]; then
		commit="$1"
	else
		commit="Commit-$(shuf -i 10000000-99999999 -n 1)"
	fi

	# Commit the changes
	log "Committing changes"
	git add -A || die
	[[ "$conf_list_added_changes" == 'true' ]] && git diff --name-status >&3
	git commit -m "$commit" || die

	# Push the commit
	log "Synchronizing the git remote"
	git push || die

	success

}


# Pushes an archi tag.
archi_cmd() {

	# Display help
	if [[ "$1" == '--help' || "$1" == '-h' || "$1" == '-?' ]]; then
		del_logfile
		msg=$(
			cat <<-END
				${title}(DESCRIPTION)$none

				\tThe ${code}tp archi$none submits an ${information}archi tag$none to the mouli.
				\t
				\t${note}If any changes have been made, then it commits all of them before creating the tag.$none

				\t${warn}If any changes have been made, it adds every current changes in the repository. Make sure to have an appropriate .gitignore file to avoid pushing trash file on the remote!$none

				${title}(USAGE)$none

				\tIt takes as parameters the ${information}name of the tag$none and the ${information}name of the commit$none that may not be used if no changes has been made.

				\t${note}The name of the archi tag should not contain the prefix \"archi-\" since it is automatically added.$none

				\tWhen no commit name is given but that it is required, it is set ${information}by default to the tag's name$none. When both commit's and tag's names are not given, a ${information}random name$none is generated and used for both of them.

				\tUsages:
				\t- ${code}tp archi <tag_name> <commit_name>$none
				\t- ${code}tp archi <tag_name>$none
				\t- ${code}tp archi$none

				${title}(EXAMPLES)$none

				\t${code}tp archi \"first\" \"Finish the proficiencies\"$none
				\t${code}tp archi \"second\" \"Remove unauthorized classes\"$none
				\t${code}tp archi \"third\"$none
				\t${code}tp archi$none
			END
		)
		myecho "$msg"
		exit 0
	fi

	# Choose a commit and tag name
	if [[ -n "$1" ]]; then
		commit="$1"
		if [[ -n "$2" ]]; then
			tag="$2"
		else
			tag="$1"
		fi
	else
		commit="$(shuf -i 10000000-99999999 -n 1)"
		tag="$commit"
	fi

	# Commit the changes
	if [[ $(git status --porcelain | wc -l) -ne "0" ]]; then
		# Commit the changes
		log "Committing changes"
		git add -A || die
		[[ "$conf_list_added_changes" == 'true' ]] && git diff --name-status >&3
		git commit -m "$commit" || die
	fi
	
	# Create a tag
	log "Creating the tag"
	git tag -ma "archi-$tag" || die

	# Push the tag and the commit
	log "Synchronizing the git remote"
	git push --follow-tags || die

	success

}


# Pushes a submit tag.
submit_cmd() {

	# Display help
	if [[ "$1" == '--help' || "$1" == '-h' || "$1" == '-?' ]]; then
		del_logfile
		msg=$(
			cat <<-END
				${title}(DESCRIPTION)$none

				\tThe ${code}tp archi$none submits an ${information}submit tag$none to the mouli.
				\t
				\t${note}If any changes have been made, then it commits all of them before creating the tag.$none

				\t${warn}If any changes have been made, it adds every current changes in the repository. Make sure to have an appropriate .gitignore file to avoid pushing trash file on the remote!$none

				\t${warn}Make sure you are ready to push a submit tag before using this command! You sould have already pushed an archi tag that succeeded and you should not have done modification between the archi and the submit tag.$none

				${title}(USAGE)$none

				\tIt takes as parameters the ${information}name of the commit$none and the ${information}name of the submit tag$none.
				\t
				\t${note}The name of the submit tag should not contain the prefix \"submit-\" since it is automatically added.$none

				\tWhen no commit name is given but that it is required, it is set ${information}by default to the tag's name$none. When both commit's and tag's names are not given, a ${information}random name$none is generated and used for both of them.

				\tUsages:
				\t- ${code}tp submit <tag_name> <commit_name>$none
				\t- ${code}tp submit <tag_name>$none
				\t- ${code}tp submit$none

				${title}(EXAMPLES)$none

				\t${code}tp submit \"adamsromance\" \"Finish the proficiencies\"$none
				\t${code}tp submit \"first\" \"VipOk\"$none
				\t${code}tp submit$none
			END
		)
		myecho "$msg"
		exit 0
	fi

	# Ask for user confirmation

	# The number the user must enter
	num="$(shuf -i 100000-999999 -n 1)"
	myecho "${bold}Are you sure that you want to push a ${red}submit$none$bold tag ?$none\nPlease enter the following number to validate: $num. Press enter with an invalid input to exit."
	read -p "> " input
	if [[ "$input" -ne "$num" ]]; then
		success "${bold}Command canceled!$none"
	fi

	# Choose a commit and tag name
	if [[ -n "$1" ]]; then
		commit="$1"
		if [[ -n "$2" ]]; then
			tag="$2"
		else
			tag="$1"
		fi
	else
		commit="$(shuf -i 10000000-99999999 -n 1)"
		tag="$commit"
	fi

	# Commit the changes
	if [[ $(git status --porcelain | wc -l) -ne "0" ]]; then
		# Commit the changes
		log "Committing changes"
		git add -A || die
		[[ "$conf_list_added_changes" == 'true' ]] && git diff --name-status >&3
		git commit -m "$commit" || die
	fi
	
	# Create a tag
	log "Creating the tag"
	git tag -ma "submit-$tag" || die

	# Push the tag and the commit
	log "Synchronizing the git remote"
	git push --follow-tags || die

	success

}


# Updates this script.
update_cmd() {

	# Display help
	if [[ "$1" == '--help' || "$1" == '-h' || "$1" == '-?' ]]; then
		del_logfile
		msg=$(
			cat <<-END
				${title}(DESCRIPTION)$none

				\t${information}Update$none this command if an update is available.

				${title}(USAGE)$none

				\tUsage: ${code}tp update$none

				${title}(EXAMPLES)$none

				\t${code}tp update$none
			END
		)
		myecho "$msg"
		exit 0
	fi

	# Find the paht to this script
	log "Finding the tp file"
	tp_path="$(which 'tp')" || die 'Could not locate the tp script.'

	# Get the newest version
	log "Downloading the newest version from the remote"
	new_version_path=$(mktemp "/tmp/tp-version-XXXXXXXXXXXXXXXXXXXX") || die
	curl 'https://raw.githubusercontent.com/lomination/tp/refs/heads/main/tp' > "$new_version_path" || die

	# Determine if an upgrade is needed
	log "Comparing remote version with local one"
	if cmp "$tp_path" "$new_version_path" ; then
		success "The local version is already up-to-date!" >&3
	else
		# Create the update script
		log "Creating the update script"
		# The path to the update script
		update_script_path="$(mktemp '/tmp/tp-version-XXXXXXXXXXXXXXXXXXXX')"
		# Write out the update script
		cat > "$update_script_path" <<-EOF
		#!/usr/bin/env bash

		exec 3>&1
		exec &> $logfile

		die() {
			echo -e "Fatal error: \$1"
			myecho "$blod${red}Fatal error:$none \$1 (logfile: $logfile)"
			exit 1
		}

		rm '$update_script_path'
		chmod +x '$tp_path' || die 'Failed to make the new script executable'
		mv '$new_version_path' '$tp_path' || die 'Failed to move the new version.'

		rm '$logfile'
		echo -e '\n$bold${green}Successfully updated!' >& 3
		exit 0
		EOF
		log "Executing the update script"
		# Make the script executable
		chmod +x "$update_script_path" || die 'Could not make the update script executable'
		# Run the script
		exec "$update_script_path" || die 'Could not exectute the update script'
	fi

}


# Shows a help message for the given command.
help_cmd() {

	del_logfile
	case "$1" in
		# Aliases
		"log"|"lg")
			log_alias '--help'
			;;
		"status"|"st")
			status_alias '--help'
			;;
		# Commands
		"init")
			init_cmd '--help'
			;;
		"save")
			save_cmd '--help'
			;;
		"archi")
			archi_cmd '--help'
			;;
		"submit")
			submit_cmd '--help'
			;;
		"update")
			update_cmd '--help'
			;;
		""|"help"|"-h"|"--help")
			msg=$(
				cat <<-END
					${title}(DESCRIPTION)$none

					\t${information}Display the documentation$none associated with a given command.

					${title}(USAGE)$none

					\tIt takes a parameter a ${information}command$none among ${code}init$none, ${code}save$none, ${code}archi$none, ${code}submit$none, ${code}update$none and ${code}help$none.

					\tUsage: ${code}tp help <command>$none

					${title}(EXAMPLES)$none

					\t${code}tp help init$none
					\t${code}tp help help$none
				END
			)
			myecho "$msg"
			exit 0
			;;
		*)
			myecho "$blod${red}Error:$none invalid command $code$1$none. Check out ${code}tp help$none for help."
			exit 1
			;;
	esac

}


### Main script ###

case "$1" in
	# Aliases
	"log"|"lg")
		log_alias
		;;
	"status"|"st")
		status_alias
		;;
	"pull"|"sync")
		pull_alias
		;;
	# Commands
	"init")
		init_cmd "$2" "$3"
		;;
	"save")
		save_cmd "$2"
		;;
	"archi")
		archi_cmd "$2" "$3"
		;;
	"submit")
		submit_cmd "$2" "$3"
		;;
	"update")
		update_cmd "$2"
		;;
	"help")
		help_cmd "$2"
		;;
	*)
		del_logfile
		myecho "${red}ERROR:$none invalid command $code$1$none. Check out ${code}tp help$none for help."
		exit 1
		;;
esac
